name: 'Setup Ubuntu Packages'
description: 'Configure Ubuntu mirrors and install packages for faster, reliable CI builds'
inputs:
  enable_mirrors:
    description: 'Enable mirror configuration for faster downloads'
    required: false
    default: 'true'
  mirror_url:
    description: 'Primary mirror URL (e.g., https://mirror.init7.net/ubuntu/)'
    required: false
    default: 'https://mirror.init7.net/ubuntu/'
  backup_mirrors:
    description: 'Backup mirror URLs (comma-separated)'
    required: false
    default: 'https://mirror.math.princeton.edu/pub/ubuntu/,https://ftp.halifax.rwth-aachen.de/ubuntu/,https://mirrors.kernel.org/ubuntu/'
  packages:
    description: 'List of packages to install (YAML list or space-separated string)'
    required: false
    default: |
      - git
      - curl
  extra_packages:
    description: 'Additional packages to install (YAML list or space-separated string)'
    required: false
    default: ''
  update_cache:
    description: 'Run apt-get update before package installation'
    required: false
    default: 'true'
  ubuntu_version:
    description: 'Ubuntu version codename (auto-detected if empty)'
    required: false
    default: ''
  retry_count:
    description: 'Number of retry attempts for package installation'
    required: false
    default: '2'
  cache_timeout:
    description: 'Timeout in seconds for package operations'
    required: false
    default: '120'

outputs:
  mirror_configured:
    description: 'Whether mirrors were configured successfully'
    value: ${{ steps.configure-mirrors.outputs.configured }}
  packages_installed:
    description: 'List of successfully installed packages'
    value: ${{ steps.install-packages.outputs.installed }}
  ubuntu_codename:
    description: 'Detected Ubuntu codename'
    value: ${{ steps.detect-version.outputs.codename }}

runs:
  using: "composite"
  steps:
    - name: Log configuration
      shell: bash
      run: |
        echo "üöÄ Ubuntu Package Setup Configuration"
        echo "======================================"
        echo "Mirror settings:"
        echo "  Enable mirrors: ${{ inputs.enable_mirrors }}"
        echo "  Primary mirror: ${{ inputs.mirror_url }}"
        echo "  Backup mirrors: ${{ inputs.backup_mirrors }}"
        echo ""
        echo "Package settings:"
        echo "  Update cache: ${{ inputs.update_cache }}"
        echo "  Retry count: ${{ inputs.retry_count }}"
        echo "  Operation timeout: ${{ inputs.cache_timeout }}s"
        echo "  Ubuntu version: ${{ inputs.ubuntu_version || 'auto-detect' }}"
        echo ""
        echo "Packages to install:"
        if [ -n "${{ inputs.packages }}" ]; then
          echo "${{ inputs.packages }}" | sed 's/^/  /'
        else
          echo "  (none specified)"
        fi
        echo ""
        echo "Extra packages:"
        if [ -n "${{ inputs.extra_packages }}" ]; then
          echo "${{ inputs.extra_packages }}" | sed 's/^/  /'
        else
          echo "  (none specified)"
        fi
        echo "======================================"
    
    - name: Detect Ubuntu version
      id: detect-version
      shell: bash
      run: |
        if [ -n "${{ inputs.ubuntu_version }}" ]; then
          CODENAME="${{ inputs.ubuntu_version }}"
          echo "Using provided Ubuntu codename: $CODENAME"
        else
          # Auto-detect Ubuntu codename
          CODENAME=$(lsb_release -sc 2>/dev/null || grep VERSION_CODENAME /etc/os-release | cut -d= -f2 | tr -d '"' || echo "noble")
          echo "Auto-detected Ubuntu codename: $CODENAME"
        fi
        echo "codename=$CODENAME" >> $GITHUB_OUTPUT
        echo "UBUNTU_CODENAME=$CODENAME" >> $GITHUB_ENV
    
    - name: Configure Ubuntu mirrors
      id: configure-mirrors
      if: inputs.enable_mirrors == 'true'
      shell: bash
      run: |
        echo "üåç Configuring Ubuntu mirrors for faster downloads..."
        echo "Primary mirror: ${{ inputs.mirror_url }}"
        echo "Ubuntu codename: $UBUNTU_CODENAME"
        
        # Backup original sources
        cp /etc/apt/sources.list /etc/apt/sources.list.backup
        
        MIRROR_URL="${{ inputs.mirror_url }}"
        # Remove trailing slash if present
        MIRROR_URL=$(echo "$MIRROR_URL" | sed 's|/$||')
        
        # Create optimized sources.list with primary mirror
        cat > /etc/apt/sources.list << EOF
        # Ubuntu Mirror Configuration - Generated by setup-ubuntu-packages action
        # Primary mirror: $MIRROR_URL (optimized for CI efficiency)
        
        # Main repository - prioritize main and universe (most CI packages)
        deb $MIRROR_URL $UBUNTU_CODENAME main universe
        deb $MIRROR_URL $UBUNTU_CODENAME-updates main universe
        
        # Additional components only if needed
        deb $MIRROR_URL $UBUNTU_CODENAME restricted multiverse
        deb $MIRROR_URL $UBUNTU_CODENAME-updates restricted multiverse
        
        # Security updates (use same mirror for reliability)
        deb $MIRROR_URL $UBUNTU_CODENAME-security main restricted universe multiverse
        
        # Skip backports by default (can be uncommented if needed)
        # deb $MIRROR_URL $UBUNTU_CODENAME-backports main restricted universe multiverse
        EOF
        
        # Quick test with timeout, fallback to backup mirrors immediately
        echo "üîç Testing mirror connectivity..."
        if timeout 5 bash -c "</dev/tcp/${MIRROR_URL#https://}/443" 2>/dev/null; then
          echo "‚úÖ Primary mirror is accessible"
          echo "configured=true" >> $GITHUB_OUTPUT
        else
          echo "‚ö†Ô∏è Primary mirror failed, switching to backup mirrors..."
          
          # Clear sources and use backup mirrors instead
          cat > /etc/apt/sources.list << EOF
        # Backup Ubuntu mirrors - primary mirror failed
        deb https://mirror.math.princeton.edu/pub/ubuntu/ $UBUNTU_CODENAME main restricted universe multiverse
        deb https://mirror.math.princeton.edu/pub/ubuntu/ $UBUNTU_CODENAME-updates main restricted universe multiverse
        deb https://mirror.math.princeton.edu/pub/ubuntu/ $UBUNTU_CODENAME-security main restricted universe multiverse
        deb https://ftp.halifax.rwth-aachen.de/ubuntu/ $UBUNTU_CODENAME main restricted universe multiverse
        deb https://ftp.halifax.rwth-aachen.de/ubuntu/ $UBUNTU_CODENAME-updates main restricted universe multiverse
        EOF
          echo "configured=fallback" >> $GITHUB_OUTPUT
        fi
        
        # Show configured sources for verification
        echo "üìã Configured package sources:"
        grep -E '^deb ' /etc/apt/sources.list | head -5
    
    - name: Install ca-certificates
      shell: bash
      run: |
        echo "üîê Installing ca-certificates for HTTPS repository access..."
        
        # Set environment for non-interactive installation
        export DEBIAN_FRONTEND=noninteractive
        export APT_LISTCHANGES_FRONTEND=none
        
        # Try to install ca-certificates using HTTP mirrors first
        # This avoids the chicken-and-egg problem of needing certificates to get certificates
        
        # Temporarily use HTTP mirrors to bootstrap ca-certificates
        cp /etc/apt/sources.list /etc/apt/sources.list.https-backup
        
        # Create temporary HTTP-only sources
        sed 's/https:/http:/g' /etc/apt/sources.list > /etc/apt/sources.list.http
        cp /etc/apt/sources.list.http /etc/apt/sources.list
        
        echo "üåê Using HTTP mirrors to bootstrap ca-certificates..."
        
        # Update with HTTP mirrors and install ca-certificates
        if apt-get update -qq && apt-get install -yqq --no-install-recommends ca-certificates; then
          echo "‚úÖ ca-certificates installed successfully"
          
          # Restore HTTPS sources now that we have certificates
          cp /etc/apt/sources.list.https-backup /etc/apt/sources.list
          echo "üîí Restored HTTPS mirrors"
        else
          echo "‚ùå Failed to install ca-certificates"
          # Keep HTTP sources as fallback
          echo "‚ö†Ô∏è Keeping HTTP mirrors as fallback"
        fi
        
        # Clean up temporary files
        rm -f /etc/apt/sources.list.http /etc/apt/sources.list.https-backup
    
    - name: Update package cache
      if: inputs.update_cache == 'true'
      shell: bash
      run: |
        echo "üì¶ Updating package cache (optimized for CI)..."
        
        # Set efficient apt configuration for CI
        export DEBIAN_FRONTEND=noninteractive
        export APT_LISTCHANGES_FRONTEND=none
        
        # Configure apt for faster CI operations
        cat > /etc/apt/apt.conf.d/99ci-optimizations << EOF
        // CI Optimizations - Faster package operations
        Acquire::Languages "none";
        Acquire::GzipIndexes "true";
        Acquire::CompressionTypes::Order:: "gz";
        APT::Get::Assume-Yes "true";
        APT::Get::Install-Recommends "false";
        APT::Get::Install-Suggests "false";
        APT::Get::Show-Upgraded "false";
        DPkg::Use-Pty "0";
        quiet "2";
        EOF
        
        # Function to run apt-get update with retry logic
        update_with_retry() {
          local attempt=1
          local max_attempts=${{ inputs.retry_count }}
          
          while [ $attempt -le $max_attempts ]; do
            echo "Cache update attempt $attempt of $max_attempts..."
            
            if timeout ${{ inputs.cache_timeout }} apt-get update -qq; then
              echo "‚úÖ Package cache updated successfully"
              return 0
            else
              echo "‚ùå Update attempt $attempt failed"
              if [ $attempt -lt $max_attempts ]; then
                echo "Retrying in 3 seconds..."
                sleep 3
              fi
            fi
            
            ((attempt++))
          done
          
          echo "üí• All update attempts failed"
          return 1
        }
        
        update_with_retry
    
    - name: Install packages
      id: install-packages
      shell: bash
      run: |
        echo "üì¶ Installing Ubuntu packages..."
        
        # Function to process package input (handles both YAML lists and space-separated strings)
        process_packages() {
          local input="$1"
          
          # Check if input looks like YAML list (starts with -)
          if echo "$input" | grep -q "^[[:space:]]*-"; then
            # Process as YAML list - extract package names after each -
            echo "$input" | grep -E "^[[:space:]]*-" | sed 's/^[[:space:]]*-[[:space:]]*//' | tr '\n' ' '
          else
            # Process as space-separated string
            echo "$input"
          fi
        }
        
        # Process base packages
        BASE_PACKAGES=$(process_packages "${{ inputs.packages }}")
        
        # Process extra packages
        EXTRA_PACKAGES=""
        if [ -n "${{ inputs.extra_packages }}" ]; then
          EXTRA_PACKAGES=$(process_packages "${{ inputs.extra_packages }}")
        fi
        
        # Combine packages
        ALL_PACKAGES="$BASE_PACKAGES $EXTRA_PACKAGES"
        
        # Remove duplicates and empty entries
        ALL_PACKAGES=$(echo "$ALL_PACKAGES" | tr ' ' '\n' | grep -v '^[[:space:]]*$' | sort -u | tr '\n' ' ' | xargs)
        
        echo "Installing packages: $ALL_PACKAGES"
        
        if [ -z "$ALL_PACKAGES" ]; then
          echo "‚ö†Ô∏è No packages specified for installation"
          echo "installed=" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Function to install packages with retry logic
        install_with_retry() {
          local attempt=1
          local max_attempts=${{ inputs.retry_count }}
          
          # Set optimized environment for package installation
          export DEBIAN_FRONTEND=noninteractive
          export APT_LISTCHANGES_FRONTEND=none
          
          while [ $attempt -le $max_attempts ]; do
            echo "Installation attempt $attempt of $max_attempts..."
            
            # Use optimized apt-get flags for CI
            if timeout ${{ inputs.cache_timeout }} apt-get install -yqq --no-install-recommends $ALL_PACKAGES; then
              echo "‚úÖ Packages installed successfully"
              echo "installed=$ALL_PACKAGES" >> $GITHUB_OUTPUT
              return 0
            else
              echo "‚ùå Installation attempt $attempt failed"
              if [ $attempt -lt $max_attempts ]; then
                echo "Retrying in 2 seconds..."
                sleep 2
                # Quick cache refresh before retry
                apt-get update -qq || true
              fi
            fi
            
            ((attempt++))
          done
          
          echo "üí• All installation attempts failed"
          return 1
        }
        
        install_with_retry
    
    - name: Verify installation
      shell: bash
      run: |
        echo "üîç Verifying installed packages..."
        
        # Function to process package input (handles both YAML lists and space-separated strings)
        process_packages() {
          local input="$1"
          
          # Check if input looks like YAML list (starts with -)
          if echo "$input" | grep -q "^[[:space:]]*-"; then
            # Process as YAML list - extract package names after each -
            echo "$input" | grep -E "^[[:space:]]*-" | sed 's/^[[:space:]]*-[[:space:]]*//' | tr '\n' ' '
          else
            # Process as space-separated string
            echo "$input"
          fi
        }
        
        # Process base packages
        BASE_PACKAGES=$(process_packages "${{ inputs.packages }}")
        
        # Process extra packages
        EXTRA_PACKAGES=""
        if [ -n "${{ inputs.extra_packages }}" ]; then
          EXTRA_PACKAGES=$(process_packages "${{ inputs.extra_packages }}")
        fi
        
        # Combine packages
        ALL_PACKAGES="$BASE_PACKAGES $EXTRA_PACKAGES"
        
        # Remove duplicates and empty entries
        ALL_PACKAGES=$(echo "$ALL_PACKAGES" | tr ' ' '\n' | grep -v '^[[:space:]]*$' | sort -u | tr '\n' ' ' | xargs)
        
        if [ -z "$ALL_PACKAGES" ]; then
          echo "No packages to verify"
          exit 0
        fi
        
        echo "Verifying packages: $ALL_PACKAGES"
        
        failed_packages=""
        for package in $ALL_PACKAGES; do
          if dpkg -l | grep -q "^ii  $package "; then
            echo "‚úÖ $package: installed"
          else
            echo "‚ùå $package: not found"
            failed_packages="$failed_packages $package"
          fi
        done
        
        if [ -n "$failed_packages" ]; then
          echo "‚ö†Ô∏è Some packages failed to install:$failed_packages"
          echo "This might not be critical if they were optional dependencies"
        else
          echo "üéâ All packages verified successfully"
        fi
    
    - name: Show package summary
      shell: bash
      run: |
        echo "üìä Package Installation Summary"
        echo "================================"
        echo "Ubuntu version: $UBUNTU_CODENAME"
        echo "Mirror configured: ${{ steps.configure-mirrors.outputs.configured || 'disabled' }}"
        echo "Packages requested: ${{ inputs.packages }} ${{ inputs.extra_packages }}"
        echo "Packages installed: ${{ steps.install-packages.outputs.installed }}"
        echo "================================"